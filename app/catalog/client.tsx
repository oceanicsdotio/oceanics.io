"use client";
import React, { useRef, useEffect, useState, useCallback, useReducer } from "react";
import Markdown from "react-markdown";
import Link from "next/link";
import specification from "@app/../specification.yaml";
import client from "@catalog/client.module.css"
/**
 * Remove the `free` method of a type definition
 * generated by wasm_bindgen.
 */
export type Initial<T> = Omit<T, "free">;
/**
 * Web worker messages that are explicitly handled in this
 * context. The shared worker may understand/send other types.
 * This is kept centrally for convenience, but can later
 * be individualized to client components if desired. Workers
 * are sometimes reused or used in parallel.
 */
export const ACTIONS = {
  getCollection: "getCollection",
  deleteEntity: "deleteEntity",
  createEntity: "createEntity",
  updateEntity: "updateEntity",
  getEntity: "getEntity",
  getIndex: "getIndex",
  getLinked: "getLinked",
  error: "error",
  status: "status",
  redirect: "redirect",
};
/**
 * Wrap Web Worker hooks as a custom hook that can be used across
 * all pages that require worker functions. Not used in the catalog
 * index.
 */
export function useWorkerFixtures() {
  /**
   * Ref to Web Worker.
   */
  const ref = useRef<Worker>(null);
  /**
   * Controls disabled until the worker is ready.
   */
  const [disabled, setDisabled] = useState(true);
  /**
   * On submission, we delegate the request to our background
   * worker, which will report on success/failure.
   */
  const post = useCallback((message: { type: string; data: any }) => {
    if (!ref.current) {
      console.error("Worker isn't ready");
      return;
    }
    const user = localStorage.getItem("gotrue.user");
    if (typeof user === "undefined" || !user) {
      const err = "! You are not logged in";
      console.error(err);
      return;
    }
    ref.current.postMessage({ ...message, data: { ...message.data, user } });
  }, []);
  return {
    post,
    disabled,
    setDisabled,
    ref,
  };
}
/**
 * The data type returned from the
 * API on successful query.
 */
type IndexItem = {
  description: string;
  name: string;
  href: string;
  url: string;
  content: string;
  "@iot.count": number;
};
type IndexData = IndexItem[];
/**
 * Single collection entry.
 * 
 * Adds standard description from the OpenAPI specification
 */
function Entry({
  "@iot.count": count,
  content,
  href,
  name,
  open,
}: IndexItem & { open: boolean }) {
  const { description } = (
    specification.components.schemas as {
      [key: string]: { description?: string };
    }
  )[name];
  return (
    <details name="exclusive" open={open}>
      <summary>
        <Link href={href} prefetch={false}>
          {content}
        </Link>
        <span>{` âœ“ ${count}`}</span>
      </summary>
      <Markdown>{description}</Markdown>
    </details>
  );
}
export function messageQueueReducer(state: string[], action: string) {
  const date = new Date();
  const time = date.toLocaleTimeString();
  const line = `[${time}] ${action}`
  return [...state, line]
}
/**
 * Link items for listing available collections.
 */
export default function IndexClient({}) {
  /**
   * Load worker once
   */
  const ref = useRef<Worker>(null);
  /**
   * Status message to understand what is going on in the background.
   */
  const [messages, appendToQueue] = useReducer(messageQueueReducer, []);
  /**
   * Index information for display and navigation.
   */
  const [index, setIndex] = useState<IndexData>([]);
  /**
   * Get Netlify user data from Local Storage and
   * load Web Worker on component mount. Checking
   * user validity is done in the worker, and
   * then error messages are propagated back.
   */
  useEffect(() => {
    appendToQueue("Ready");
    ref.current = new Worker(new URL("@catalog/worker.ts", import.meta.url), {
      type: "module",
    });
    function workerMessageHandler({ data: { data, type } }: MessageEvent) {
      switch (type) {
        case ACTIONS.getIndex:
          setIndex(data);
          return;
        case ACTIONS.error:
          appendToQueue(data.message);
          return;
        case ACTIONS.status:
          appendToQueue(data.message);
          return;
        default:
          console.warn("@client", type, data);
          return;
      }
    }
    ref.current.addEventListener("message", workerMessageHandler, {
      passive: true,
    });
    const user = localStorage.getItem("gotrue.user");
    appendToQueue("Authenticating");
    ref.current.postMessage({
      type: ACTIONS.getIndex,
      data: { user },
    });
    const handle = ref.current; // constant ref for clean up callback
    return () => {
      handle.removeEventListener("message", workerMessageHandler);
    };
  }, []);
  // Display Component
  return (
    <>
      <div className={client.messages}>
        {messages.toReversed().map((message: string) => <div>{message}</div>)}
      </div>
      {index.map(({ href, ...rest }, ind) => (
        <Entry key={href} open={ind === 0} href={href} {...rest} />
      ))}
    </>
  );
}
